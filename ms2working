import argparse
import math
import sys

# now we need to set those parameters from the given flags
parser = argparse.ArgumentParser(description='Cache Simulator')

# set the flags we will accept
parser.add_argument('-s', type=int, help='Cache Size - KB', dest='cache_size') # (8, 8192) KB
parser.add_argument('-b', type=int, help='Block Size - bytes', dest='block_size') # (8, 64) Bytes
parser.add_argument('-a', type=int, help='Associativity', dest='associativity') # (1, 2, 4, 8, 16)
parser.add_argument('-r', type=str, help='Replacement Policy', dest='replacement_policy') # RR or RND (0 for RR, 1 for RND)
parser.add_argument('-p', type=int, help='Physical Memory - MB', dest='physical_memory') # 128MB to 4GB (4096MB)
parser.add_argument('-u', type=int, help='Percentage of physical mem used by OS', dest='utilization') # 0-100%
parser.add_argument('-n', type=int, help='Instructions / Time Slice', dest='instructions') # 1-All, -1 for All
parser.add_argument('-f', type=str, help='Trace File Name', dest='trace_file', action='append') # required 1, up to 3


# parse the parameters
args = parser.parse_args()

# error trapping

# Cache Size (-s) - KB (8, 8192)
cache_size = args.cache_size
if cache_size is None:
    print('Error: Cache Size (-s) is required!')
    sys.exit(1)
if not (8 <= cache_size <= 8192):
    print('Error: Cache Size must be between 8 and 8192 KB!')
    sys.exit(1)

# Block Size (-b) - bytes (8, 64)
block_size = args.block_size
if block_size is None:
    print('Error: Block Size (-b) is required!')
    sys.exit(1)
if not (8 <= block_size <= 64):
    print('Error: Block Size must be between 8 and 64 bytes!')
    sys.exit(1)
if (block_size & (block_size - 1)) != 0: # Check power of 2
    print('Error: Block Size must be a power of 2!')
    sys.exit(1)

# Associativity (-a) (1, 2, 4, 8, 16)
associativity = args.associativity
valid_associativity = {1, 2, 4, 8, 16}
if associativity is None:
    print('Error: Associativity (-a) is required!')
    sys.exit(1)
if associativity not in valid_associativity:
    print('Error: Associativity must be 1, 2, 4, 8, or 16!')
    sys.exit(1)

# Replacement Policy (-r) (RR=0 or RND=1)
replacement_policy = args.replacement_policy
if replacement_policy is None:
    print('Error: Replacement Policy (-r) is required!')
    sys.exit(1)

replacement_policy = replacement_policy.upper()

if replacement_policy not in {'RR', 'RND'}:
    print('Error: Replacement Policy must be RR (Round Robin) or RND (Random)!')
    sys.exit(1)

if replacement_policy=="RR":
    replacement_policy="Round Robin"
elif replacement_policy=="RND":
    replacement_policy="Random"

# Physical Memory (-p) - MB (128, 4096)
physical_memory = args.physical_memory
if physical_memory is None:
    print('Error: Physical Memory (-p) is required!')
    sys.exit(1)
if not (128 <= physical_memory <= 4096):
    print('Error: Physical Memory must be between 128 and 4096 MB!')
    sys.exit(1)
if (physical_memory & (physical_memory - 1)) != 0: # Check power of 2
    print('Error: Physical Memory must be a power of 2!')
    sys.exit(1)

# % physical mem used by OS (-u) (0-100)
utilization = args.utilization
if utilization is None:
    print('Error: Utilization (-u) is required!')
    sys.exit(1)
if not (0 <= utilization <= 100):
    print('Error: Utilization must be between 0 and 100%!')
    sys.exit(1)

# Instructions / Time Slice (-n) (1-All, -1 for All)
instructions = args.instructions
if instructions is None:
    print('Error: Instructions (-n) is required!')
    sys.exit(1)
if not (instructions == -1 or instructions >= 1):
    print('Error: Instructions / Time Slice must be -1 or a positive integer!')
    sys.exit(1)

# Trace File Name (-f) (1, up to 3)
trace_files = args.trace_file
num_trace_files = len(args.trace_file)
if not trace_files:
    print('Error: At least one Trace File (-f) is required!')
    sys.exit(1)
num_trace_files = len(trace_files)
if not (1 <= num_trace_files <= 3):
    print(f'Error: Must specify between 1 and 3 Trace Files. You provided {num_trace_files}.')
    sys.exit(1)


total_blocks = (cache_size*1024) / block_size  #convert cache size to byte

block_offset = math.log2(block_size)

rows = total_blocks/ associativity

index = math.log2(rows)

physical_memory_bits = math.log2(physical_memory*(2**20)) #have to adjust MB

tag = physical_memory_bits - index - block_offset

overhead = ((tag+1)*total_blocks)/8

footprint = cache_size*1024 + overhead

readable_footprint = math.ceil(footprint / 1024)

cost = readable_footprint * 0.07

pages = physical_memory*1024//4  #assuming 4KB pages

system_pages = math.ceil((utilization / 100) * pages)

user_pages = pages - system_pages

page_bits = math.log2(pages)

pte_bits = page_bits + 1

total_ram = (512*1024*num_trace_files*pte_bits)/8

#print out

print('Cache Simulator - CS 3853 - Team #17')
    
instructions_str = 'All' if instructions == -1 else str(instructions)

print('\nTrace File(s):')
for file in trace_files:
    print(f'\t{file}')

print('\n***** Cache Input Parameters *****')

print()

cache_parameters = {
    'Cache Size': f'{cache_size} KB',
    'Block Size': f'{block_size} bytes',
    'Associativity': str(associativity),
    'Replacement Policy': replacement_policy,
    'Physical Memory': f'{physical_memory} MB',
    'Percent Memory Used by System': f'{utilization}.0%',
    'Instructions / Time Slice': instructions_str
}

for parameter, value in cache_parameters.items():
    print(f"{parameter:<32}{value}")

print('\n***** Cache Calculated Values *****\n')
print(f"{'Total # Blocks':<32}{total_blocks:.0f}")
print(f"{'Tag Size:':<32}{tag:.0f} bits")
print(f"{'Index Size:':<32}{index:.0f} bits")
print(f"{'Total # Rows:':<32}{rows:.0f}")
print(f"{'Overhead Size:':<32}{overhead:.0f} bytes")
print(f"{'Implementation Memory Size:':<32}{readable_footprint:.2f} KB ({footprint:.0f} bytes)")
print(f"{'Cost:':<32}${cost:.2f} @ $0.07 per KB")

print('\n****** Physical Memory Calculated Values *****\n')
print(f"{'Number of Physical Pages:':<32}{pages:.0f}")
print(f"{'Number of Pages for System:':<32}{system_pages}")
print(f"{'Size of Page Table Entry:':<32}{pte_bits:.0f} bits")
print(f"{'Total RAM for Page Table(s):':<32}{total_ram:.0f} bytes")


#milestone 2 begins here

pagesAvailable = pages - system_pages #physical pages available are the number of pages total - ones used by system



usedEntries_arr = [0] * num_trace_files #hold the values for each trace file to print at end
percent_arr = [0.0] * num_trace_files
wastedBytes_arr = [0] * num_trace_files
count = 0
pageTableHits = 0
pageFaults = 0
pagesFromFree = 0

for tracefile in args.trace_file: 
        
    free_pages = list(range(pagesAvailable)) #don't need actual page addresses yet but will have to add later

    virtualPageTable = {} # individual page table for each 
        
    used_physical_pages = set() 
    
    with open(tracefile, "r") as curFile:

        for line in curFile:

#go thru each trace file and open each one to read into variables

            if line.startswith("EIP"):
                length = int(line[5:7])
                startAddress = line[10:18]
                    
            elif line.startswith("dstM"):

                if(line[15] != "-"):

                    destAddress = line[6:14]

                    vpn = int(destAddress, 16) // 4096 #convert hex to dec to get the actual number

                    if vpn in virtualPageTable:  
                        pageTableHits +=1 

                    else:

                        if free_pages:
                            ppn = free_pages.pop()
                            virtualPageTable[vpn] = ppn
                            used_physical_pages.add(ppn)
                            usedEntries_arr[count]+=1
                           
                        else:
                            pageFaults +=1                

                if(line[44] != "-"):

                    sourceAddress = line[33:42]

                    vpn = int(sourceAddress, 16) // 4096 #convert hex to dec to get the actual number

                    if vpn in virtualPageTable: 
                        pageTableHits +=1 

                    else:

                        if free_pages:
                            ppn = free_pages.pop()
                            virtualPageTable[vpn] = ppn
                            used_physical_pages.add(ppn)
                            usedEntries_arr[count]+=1
            
                        else:
                            pageFaults +=1    

        percent_arr[count] = len(used_physical_pages)/pagesAvailable * 100 


        pagesFromFree += (pagesAvailable - len(free_pages))

                    #virtual page mapping logic need to calculate used entries, wasted page table, and percent
#total page table space - entries converted to bytes
        wastedBytes_arr[count] = 512*1024-usedEntries_arr[count]*(pte_bits/8)

        count+=1

    virtualPagesMapped = pageTableHits + pagesFromFree

print('\n***** VIRTUAL MEMORY SIMULATION RESULTS *****')

print()

print(f"{'Physical Pages Used By SYSTEM:  ':<32}{system_pages}")
print(f"{'Pages Available to User:':<32}{pagesAvailable}\n")
print(f"{'Virtual Pages Mapped:':<32}{virtualPagesMapped}")
print(f"{'':<8}{'------------------------------'}")
print(f"{'        Page Table Hits:':<32}{pageTableHits}\n")
print(f"{'        Pages From Free:':<32}{pagesFromFree}\n")
print(f"{'        Total Page Faults:':<32}{pageFaults}\n\n")

for i in range(num_trace_files):
    print(f"[{i}] {trace_files[i]}:")
    print(f"{'        Used Page Table Entries: '}{usedEntries_arr[i]} ({percent_arr[i]:.2f}%)")
    print(f"{'        Page Table Wasted: '}{wastedBytes_arr[i]:.0f} bytes\n")




